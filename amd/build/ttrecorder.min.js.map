{"version":3,"file":"ttrecorder.min.js","sources":["../src/ttrecorder.js"],"sourcesContent":["define(['jquery', 'core/log','core/notification', 'mod_readaloud/ttaudiohelper','mod_readaloud/ttbrowserrec',\r\n    'core/str','mod_readaloud/timer','mod_readaloud/ttmsspeech'],\r\n    function ($, log, notification, audioHelper, browserRec, str, timer, msspeech) {\r\n    \"use strict\"; // jshint ;_;\r\n    /*\r\n    *  The TT recorder\r\n     */\r\n\r\n    log.debug('TT Recorder: initialising');\r\n\r\n    return {\r\n        waveHeight: 75,\r\n        audio: {\r\n            stream: null,\r\n            blob: null,\r\n            dataURI: null,\r\n            start: null,\r\n            end: null,\r\n            isRecording: false,\r\n            isRecognizing: false,\r\n            isWaiting: false,\r\n            transcript: null\r\n        },\r\n        submitting: false,\r\n        owner: '',\r\n        controls: {},\r\n        uniqueid: null,\r\n        audio_updated: null,\r\n        maxtime: 0,\r\n        passagehash: null,\r\n        region: null,\r\n        asrurl: null,\r\n        lang: null,\r\n        browserrec: null,\r\n        usebrowserrec: false,\r\n        currentTime: 0,\r\n        stt_guided: false,\r\n        currentPrompt: false,\r\n        speechtoken: '',\r\n        speechtokentype: '',\r\n        forcestreaming: false,\r\n        is_streaming: false,\r\n        using_msspeech: false,\r\n        strings: {},\r\n\r\n        //for making multiple instances\r\n        clone: function () {\r\n            return $.extend(true, {}, this);\r\n        },\r\n\r\n        init: function(opts){\r\n\r\n            var that = this;\r\n            this.uniqueid=opts['uniqueid'];\r\n            this.callback=opts['callback'];\r\n            this.stt_guided = opts['stt_guided'] ? opts['stt_guided'] : false;\r\n            this.init_strings();\r\n            this.prepare_html();\r\n            this.controls.recordercontainer.show();\r\n            this.register_events();\r\n\r\n            //token check\r\n            this.using_msspeech = this.can_msspeech();\r\n            if(this.using_msspeech){\r\n                var referencetext = opts['referencetext'];\r\n                msspeech.init(this.speechtoken, this.region, this.lang, referencetext);\r\n            }\r\n\r\n            // Callback: Timer updates.\r\n            var handle_timer_update = function(){\r\n                var displaytime = that.timer.fetch_display_time();\r\n                that.controls.timerstatus.html(displaytime);\r\n                log.debug('timer_seconds: ' + that.timer.seconds);\r\n                log.debug('displaytime: ' + displaytime);\r\n                if (that.timer.seconds == 0 && that.timer.initseconds > 0) {\r\n                    that.update_audio('isRecognizing', true);\r\n                    if(that.usebrowserrec){\r\n                        that.browserrec.stop();\r\n                    }else{\r\n                        that.audiohelper.stop();\r\n                    }\r\n                }\r\n            };\r\n\r\n            // Callback: Recorder device errors.\r\n            var on_error = function(error) {\r\n                switch (error.name) {\r\n                    case 'PermissionDeniedError':\r\n                    case 'NotAllowedError':\r\n                        notification.alert(\"Error\",that.strings.allowmicaccess, \"OK\");\r\n                        break;\r\n                    case 'DevicesNotFoundError':\r\n                    case 'NotFoundError':\r\n                        notification.alert(\"Error\",that.strings.nomicdetected, \"OK\");\r\n                        break;\r\n                    default:\r\n                        //other errors, like from Edge can fire repeatedly so a notification is not a good idea\r\n                        //notification.alert(\"Error\", error.name, \"OK\");\r\n                        log.debug(\"Error\", error.name);\r\n                }\r\n            };\r\n\r\n            // Callback: Recording stopped.\r\n            var on_stopped = function(blob) {\r\n                that.timer.stop()\r\n\r\n                //if the blob is undefined then the user is super clicking or something\r\n                if(blob===undefined){\r\n                    return;\r\n                }\r\n\r\n                //Update our current audio object\r\n                var newaudio = {\r\n                    blob: blob,\r\n                    dataURI: URL.createObjectURL(blob),\r\n                    end: new Date(),\r\n                    isRecording: false,\r\n                    length: Math.round((that.audio.end - that.audio.start) / 1000),\r\n                };\r\n                that.update_audio(newaudio);\r\n\r\n                //if we are not streaming then upload_transcribe (ie send to poodll servers)\r\n                if(!that.is_streaming){\r\n                    if(that.using_msspeech){\r\n                        that.do_msspeech(that.audio.blob, function(response){\r\n                            that.gotMSResults(response);\r\n                            that.update_audio('isRecognizing',false);\r\n                        });\r\n                    }else{\r\n                        that.upload_transcribe(that.audio.blob, function(response){\r\n                            log.debug(response);\r\n                            if(response.data.result===\"success\" && response.data.transcript){\r\n                                that.gotRecognition(response.data.transcript.trim());\r\n                            } else {\r\n                                notification.alert(\"Information\",that.strings.speechnotrecognized, \"OK\");\r\n                            }\r\n                            that.update_audio('isRecognizing',false);\r\n                        });\r\n                    }\r\n                }\r\n\r\n            };\r\n\r\n            // Callback: Recorder device got stream - start recording\r\n            var on_gotstream=  function(stream) {\r\n                var newaudio={stream: stream, isRecording: true, isWaiting: false};\r\n                that.update_audio(newaudio);\r\n            };\r\n\r\n            //If browser rec (Chrome Speech Rec) \r\n            if(browserRec.will_work_ok() && ! this.stt_guided && !this.forcestreaming && !this.using_msspeech){\r\n                //Init browserrec\r\n                log.debug(\"using browser rec\");\r\n                this.browserrec = browserRec.clone();\r\n                this.browserrec.init(this.lang,this.waveHeight,this.uniqueid);\r\n                this.usebrowserrec=true;\r\n\r\n                //set up events\r\n                that.browserrec.onerror = on_error;\r\n                that.browserrec.onend = function(){\r\n                        //do something here\r\n                };\r\n                that.browserrec.onstart = function(){\r\n                    //do something here\r\n                };\r\n                that.browserrec.onfinalspeechcapture=function(speechtext){\r\n                    that.gotRecognition(speechtext);\r\n                    that.update_audio('isRecording',false);\r\n                    that.update_audio('isRecognizing',false);\r\n                };\r\n\r\n                that.browserrec.oninterimspeechcapture=function(speechtext){\r\n                    that.gotInterimRecognition(speechtext);\r\n                };\r\n\r\n            //If we have a streaming token\r\n            }else if( this.can_stream() && !this.stt_guided ) {\r\n                this.is_streaming = true;\r\n                //Init streaming audio helper\r\n                log.debug(\"using audio helper and streaming rec\");\r\n                this.audiohelper =  audioHelper.clone();\r\n                this.audiohelper.init(this.waveHeight,this.uniqueid, this);\r\n\r\n                that.audiohelper.onError = on_error;\r\n                that.audiohelper.onStop = on_stopped;\r\n                that.audiohelper.onStream = on_gotstream;\r\n                that.audiohelper.onfinalspeechcapture = function(speechtext){\r\n                    that.gotRecognition(speechtext);\r\n                    that.update_audio('isRecording',false);\r\n                    that.update_audio('isRecognizing',false);\r\n                };\r\n                that.audiohelper.oninterimspeechcapture = function(speechtext){\r\n                    that.gotInterimRecognition(speechtext);\r\n                };\r\n                \r\n            //If upload_transcriber\r\n            } else {\r\n                //set up upload_transcriber\r\n                log.debug(\"using upload_transcriber\");\r\n                this.audiohelper =  audioHelper.clone();\r\n                this.audiohelper.init(this.waveHeight,this.uniqueid,this);\r\n\r\n                that.audiohelper.onError = on_error;\r\n                that.audiohelper.onStop = on_stopped;\r\n                that.audiohelper.onStream = on_gotstream;\r\n\r\n            }//end of setting up recorders\r\n\r\n            // Setting up timer.\r\n            this.timer = timer.clone();\r\n            this.timer.init(this.maxtime, handle_timer_update);\r\n            // Init the timer readout\r\n            handle_timer_update();\r\n        },\r\n\r\n        can_stream: function( ){\r\n            return (this.speechtoken && this.speechtoken !== 'false'&& this.speechtokentype == 'assemblyai' && !this.stt_guided);\r\n        },\r\n\r\n        can_msspeech: function( ){\r\n            return (this.speechtoken && this.speechtoken !== 'false' && this.speechtokentype === 'msspeech');\r\n        },\r\n\r\n        blobToArrayBuffer: function (blob) {\r\n            return new Promise((resolve, reject) => {\r\n                const reader = new FileReader();\r\n                reader.onload = function(event) {\r\n                    resolve(event.target.result);\r\n                };\r\n                reader.onerror = function(error) {\r\n                    reject(error);\r\n                };\r\n                reader.readAsArrayBuffer(blob);\r\n            });\r\n        },\r\n\r\n        init_strings: function(){\r\n            var that=this;\r\n            str.get_strings([\r\n                { \"key\": \"allowmicaccess\", \"component\": 'mod_readaloud'},\r\n                { \"key\": \"nomicdetected\", \"component\": 'mod_readaloud'},\r\n                { \"key\": \"speechnotrecognized\", \"component\": 'mod_readaloud'},\r\n\r\n            ]).done(function (s) {\r\n                var i = 0;\r\n                that.strings.allowmicaccess = s[i++];\r\n                that.strings.nomicdetected = s[i++];\r\n                that.strings.speechnotrecognized = s[i++];\r\n            });\r\n        },\r\n\r\n        prepare_html: function(){\r\n            this.controls.recordercontainer =$('#ttrec_container_' + this.uniqueid);\r\n            this.controls.recorderbutton = $('#' + this.uniqueid + '_recorderdiv');\r\n            this.controls.waveform = $('#' + this.uniqueid + '_waveform');\r\n            this.controls.timerstatus = $('.timerstatus_' + this.uniqueid);\r\n            this.passagehash = this.controls.recorderbutton.data('passagehash');\r\n            this.region=this.controls.recorderbutton.data('region');\r\n            this.lang=this.controls.recorderbutton.data('lang');\r\n            this.asrurl=this.controls.recorderbutton.data('asrurl');\r\n            this.speechtoken=this.controls.recorderbutton.data('speechtoken');\r\n            this.speechtokentype=this.controls.recorderbutton.data('speechtokentype');\r\n            this.forcestreaming=this.controls.recorderbutton.data('forcestreaming');\r\n            this.maxtime=this.controls.recorderbutton.data('maxtime');\r\n            this.waveHeight=this.controls.recorderbutton.data('waveheight');\r\n        },\r\n\r\n        silence_detected: function(){\r\n            if(this.audio.isRecording){\r\n                this.toggleRecording();\r\n            }\r\n        },\r\n\r\n        update_audio: function(newprops,val){\r\n            if (typeof newprops === 'string') {\r\n                log.debug('update_audio:' + newprops + ':' + val);\r\n                if (this.audio[newprops] !== val) {\r\n                    this.audio[newprops] = val;\r\n                    this.audio_updated();\r\n                }\r\n            }else{\r\n                for (var theprop in newprops) {\r\n                    this.audio[theprop] = newprops[theprop];\r\n                    log.debug('update_audio:' + theprop + ':' + newprops[theprop]);\r\n                }\r\n                this.audio_updated();\r\n            }\r\n        },\r\n\r\n        register_events: function(){\r\n            var that = this;\r\n            this.controls.recordercontainer.click(function(){\r\n                that.toggleRecording();\r\n            });\r\n\r\n            this.audio_updated=function() {\r\n                //pointer\r\n                if (that.audio.isRecognizing || that.audio.isWaiting ) {\r\n                    that.show_recorder_pointer('none');\r\n                } else {\r\n                    that.show_recorder_pointer('auto');\r\n                }\r\n                //the color\r\n                //we no longer swap out colors for waiting .. its too fast and a bit jarring\r\n                if(that.audio.isRecognizing || that.audio.isRecording || that.audio.isWaiting){\r\n                    this.controls.recorderbutton.removeClass('ttrec_ready');\r\n                    this.controls.recorderbutton.removeClass('ttrec_waiting');\r\n                    this.controls.waveform.removeClass('ttrec_waiting');\r\n                    this.controls.recorderbutton.addClass('ttrec_engaged');\r\n                }else if (that.audio.isWaiting && false) {\r\n                    this.controls.recorderbutton.removeClass('ttrec_engaged');\r\n                    this.controls.recorderbutton.removeClass('ttrec_ready');\r\n                    this.controls.recorderbutton.addClass('ttrec_waiting');\r\n                    this.controls.waveform.addClass('ttrec_waiting');\r\n                }else{\r\n                    this.controls.recorderbutton.removeClass('ttrec_engaged');\r\n                    this.controls.recorderbutton.removeClass('ttrec_waiting');\r\n                    this.controls.waveform.removeClass('ttrec_waiting');\r\n                    this.controls.recorderbutton.addClass('ttrec_ready');\r\n                }\r\n\r\n                //the font awesome spinner/mic/square\r\n                that.controls.recorderbutton.html(that.recordBtnContent());\r\n            };\r\n\r\n        },\r\n\r\n        show_recorder_pointer: function(show){\r\n            if(show) {\r\n                this.controls.recorderbutton.css('pointer-events', 'none');\r\n            }else{\r\n                this.controls.recorderbutton.css('pointer-events', 'auto');\r\n            }\r\n\r\n        },\r\n\r\n        gotMSResults:function(results){\r\n            log.debug(results);\r\n            var message={};\r\n            message.type='pronunciation_results';\r\n            message.results = results;\r\n            this.callback(message);\r\n        },\r\n\r\n        gotRecognition:function(transcript){\r\n            log.debug('transcript:' + transcript);\r\n            if(transcript.trim()==''){return;}\r\n            var message={};\r\n            message.type='speech';\r\n            message.capturedspeech = transcript;\r\n            this.callback(message);\r\n        },\r\n\r\n        gotInterimRecognition:function(transcript){\r\n            var message={};\r\n            message.type='interimspeech';\r\n            message.capturedspeech = transcript;\r\n           //POINT\r\n            this.callback(message);\r\n        },\r\n\r\n        cleanWord: function(word) {\r\n            return word.replace(/['!\"#$%&\\\\'()\\*+,\\-\\.\\/:;<=>?@\\[\\\\\\]\\^_`{|}~']/g,\"\").toLowerCase();\r\n        },\r\n\r\n        recordBtnContent: function() {\r\n\r\n            if(!this.audio.isRecognizing){\r\n\r\n                if (this.audio.isRecording) {\r\n                    return '<i class=\"fa fa-stop\">';\r\n\r\n                } else if(this.audio.isWaiting) {\r\n                    return '<i class=\"fa fa-solid fa-cog fa-spin\">';\r\n\r\n                } else {\r\n                    return '<i class=\"fa fa-microphone\">';\r\n                }\r\n            } else {\r\n                return '<i class=\"fa fa-spinner fa-spin\">';\r\n            }\r\n        },\r\n        toggleRecording: function() {\r\n            var that =this;\r\n\r\n            //If we are recognizing, then we want to discourage super click'ers\r\n            if (this.audio.isRecognizing || this.audio.isWaiting) {\r\n                return;\r\n            }\r\n\r\n            //If we are currently recording\r\n            if (this.audio.isRecording) {\r\n                that.timer.stop();\r\n\r\n                //If using Browser Rec (chrome speech)\r\n                if(this.usebrowserrec){\r\n                    that.update_audio('isRecording',false);\r\n                    that.update_audio('isRecognizing',true);\r\n                    this.browserrec.stop();\r\n                //If using upload_transcriber or streaming\r\n                }else{\r\n                    this.update_audio('isRecognizing',true);\r\n                    this.audiohelper.stop();\r\n                }\r\n\r\n             //If we are NOT currently recording\r\n            } else {\r\n                // Run the timer\r\n                that.currentTime = 0;\r\n                that.timer.reset();\r\n                that.timer.start();\r\n                \r\n\r\n                //If using Browser Rec (chrome speech)\r\n                if(this.usebrowserrec){\r\n                    this.update_audio('isRecording',true);\r\n                    this.browserrec.start();\r\n\r\n                //If using Audio helper for upload_transcriber or streaming\r\n                }else {\r\n                    var newaudio = {\r\n                        stream: null,\r\n                        blob: null,\r\n                        dataURI: null,\r\n                        start: new Date(),\r\n                        end: null,\r\n                        isRecording: false,\r\n                        isRecognizing: false,\r\n                        isWaiting: true,\r\n                        transcript: null\r\n                    };\r\n                    this.update_audio(newaudio);\r\n                    this.audiohelper.start();\r\n                }\r\n            }\r\n        },\r\n\r\n        upload_transcribe: function(blob, callback) {\r\n            var bodyFormData = new FormData();\r\n            var blobname = this.uniqueid + Math.floor(Math.random() * 100) +  '.wav';\r\n            bodyFormData.append('audioFile', blob, blobname);\r\n            bodyFormData.append('scorer', this.passagehash);\r\n            if(this.stt_guided) {\r\n                bodyFormData.append('strictmode', 'false');\r\n            }else{\r\n                bodyFormData.append('strictmode', 'true');\r\n            }\r\n            //prompt is used by whisper and other transcibers down the line\r\n            if(this.currentPrompt!==false){\r\n                bodyFormData.append('prompt', this.currentPrompt);\r\n            }\r\n            bodyFormData.append('lang', this.lang);\r\n            bodyFormData.append('wwwroot', M.cfg.wwwroot);\r\n\r\n            var oReq = new XMLHttpRequest();\r\n            oReq.open(\"POST\", this.asrurl, true);\r\n            oReq.onUploadProgress= function(progressEvent) {};\r\n            oReq.onload = function(oEvent) {\r\n                if (oReq.status === 200) {\r\n                    callback(JSON.parse(oReq.response));\r\n                } else {\r\n                    callback({data: {result: \"error\"}});\r\n                    log.debug(oReq.error);\r\n                }\r\n            };\r\n            try {\r\n                oReq.send(bodyFormData);\r\n            }catch(err){\r\n                callback({data: {result: \"error\"}});\r\n                log.debug(err);\r\n            }\r\n        },\r\n\r\n        do_msspeech: function(blob, callback) {\r\n            msspeech.recognize(blob,callback)\r\n        },\r\n\r\n    };//end of return value\r\n\r\n});"],"names":["define","$","log","notification","audioHelper","browserRec","str","timer","msspeech","debug","waveHeight","audio","stream","blob","dataURI","start","end","isRecording","isRecognizing","isWaiting","transcript","submitting","owner","controls","uniqueid","audio_updated","maxtime","passagehash","region","asrurl","lang","browserrec","usebrowserrec","currentTime","stt_guided","currentPrompt","speechtoken","speechtokentype","forcestreaming","is_streaming","using_msspeech","strings","clone","extend","this","init","opts","that","callback","init_strings","prepare_html","recordercontainer","show","register_events","can_msspeech","referencetext","handle_timer_update","displaytime","fetch_display_time","timerstatus","html","seconds","initseconds","update_audio","stop","audiohelper","on_error","error","name","alert","allowmicaccess","nomicdetected","on_stopped","undefined","newaudio","URL","createObjectURL","Date","length","Math","round","do_msspeech","response","gotMSResults","upload_transcribe","data","result","gotRecognition","trim","speechnotrecognized","on_gotstream","will_work_ok","can_stream","onError","onStop","onStream","onfinalspeechcapture","speechtext","oninterimspeechcapture","gotInterimRecognition","onerror","onend","onstart","blobToArrayBuffer","Promise","resolve","reject","reader","FileReader","onload","event","target","readAsArrayBuffer","get_strings","done","s","i","recorderbutton","waveform","silence_detected","toggleRecording","newprops","val","theprop","click","show_recorder_pointer","removeClass","addClass","recordBtnContent","css","results","message","capturedspeech","cleanWord","word","replace","toLowerCase","reset","bodyFormData","FormData","blobname","floor","random","append","M","cfg","wwwroot","oReq","XMLHttpRequest","open","onUploadProgress","progressEvent","oEvent","status","JSON","parse","send","err","recognize"],"mappings":"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"}