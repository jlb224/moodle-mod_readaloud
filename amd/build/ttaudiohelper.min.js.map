{"version":3,"file":"ttaudiohelper.min.js","sources":["../src/ttaudiohelper.js"],"sourcesContent":["define(['jquery', 'core/log', 'mod_readaloud/ttwavencoder'], function ($, log, wavencoder) {\r\n    \"use strict\"; // jshint ;_;\r\n    /*\r\n    This file is the engine that drives audio rec and canvas drawing. TT Recorder is the just the glory kid\r\n     */\r\n\r\n    log.debug('TT Audio Helper initialising');\r\n\r\n    return {\r\n        encoder: null,\r\n        microphone: null,\r\n        isRecording: false,\r\n        audioContext: null,\r\n        processor: null,\r\n        uniqueid: null,\r\n        alreadyhadsound: false, //only start silence detection after we got a sound. Silence detection is end of speech.\r\n        silencecount: 0, //how many intervals of consecutive silence so far\r\n        silenceintervals: 15, //how many consecutive silence intervals (100ms) = silence detected\r\n        silencelevel: 25, //below this volume level = silence\r\n\r\n        config: {\r\n            bufferLen: 4096,\r\n            numChannels: 2,\r\n            mimeType: 'audio/wav'\r\n        },\r\n\r\n        //for making multiple instances\r\n        clone: function () {\r\n            return $.extend(true, {}, this);\r\n        },\r\n\r\n\r\n        init: function(waveHeight, uniqueid, therecorder) {\r\n\r\n            this.waveHeight = waveHeight;\r\n            this.uniqueid=uniqueid;\r\n            this.therecorder= therecorder;\r\n            this.prepare_html();\r\n\r\n\r\n            window.AudioContext = window.AudioContext || window.webkitAudioContext;\r\n\r\n        },\r\n\r\n        onStop: function() {},\r\n        onStream: function() {},\r\n        onError: function() {},\r\n\r\n\r\n        prepare_html: function(){\r\n            this.canvas =$('#' + this.uniqueid + \"_waveform\");\r\n            this.canvasCtx = this.canvas[0].getContext(\"2d\");\r\n        },\r\n\r\n        start: function(shadow) {\r\n\r\n            var that =this;\r\n\r\n            // Audio context\r\n            this.audioContext = new AudioContext();\r\n            if (this.audioContext.createJavaScriptNode) {\r\n                this.processor = this.audioContext.createJavaScriptNode(this.config.bufferLen, this.config.numChannels, this.config.numChannels);\r\n            } else if (this.audioContext.createScriptProcessor) {\r\n                this.processor = this.audioContext.createScriptProcessor(this.config.bufferLen, this.config.numChannels, this.config.numChannels);\r\n            } else {\r\n                log.debug('WebAudio API has no support on this browser.');\r\n            }\r\n            this.processor.connect(this.audioContext.destination);\r\n\r\n\r\n            var gotStreamMethod= function(stream) {\r\n                that.onStream(stream);\r\n                that.isRecording = true;\r\n                that.therecorder.update_audio('isRecording',true);\r\n                that.tracks = stream.getTracks();\r\n\r\n                //lets check the noise suppression and echo reduction on these\r\n                for(var i=0; i<that.tracks.length; i++){\r\n                    var track = that.tracks[i];\r\n                    if(track.kind == \"audio\"){\r\n                        var settings = track.getSettings();\r\n                        if(settings.noiseSuppression){\r\n                            log.debug(\"Noise Suppression is on\");\r\n                        }else{\r\n                            log.debug(\"Noise Suppression is off\");\r\n                        }\r\n                        if(settings.echoCancellation){\r\n                            log.debug(\"Echo Cancellation is on\");\r\n                        }else{\r\n                            log.debug(\"Echo Cancellation is off\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Create a MediaStreamAudioSourceNode for the microphone\r\n                that.microphone = that.audioContext.createMediaStreamSource(stream);\r\n\r\n                // Connect the AudioBufferSourceNode to the gainNode\r\n                that.microphone.connect(that.processor);\r\n                that.encoder = wavencoder.clone();\r\n                that.encoder.init(that.audioContext.sampleRate, 2);\r\n\r\n                // Give the node a function to process audio events\r\n                that.processor.onaudioprocess = function(event) {\r\n                    that.encoder.encode(that.getBuffers(event));\r\n                };\r\n\r\n                that.listener = that.audioContext.createAnalyser();\r\n                that.microphone.connect(that.listener);\r\n                that.listener.fftSize = 2048; // 256\r\n\r\n                that.bufferLength = that.listener.frequencyBinCount;\r\n                that.analyserData = new Uint8Array(that.bufferLength);\r\n                that.volumeData = new Uint8Array(that.bufferLength);\r\n\r\n                that.canvasCtx.clearRect(0, 0, that.canvas.width()*2, that.waveHeight*2);\r\n                that.alreadyhadsound= false;\r\n                that.silencecount= 0;\r\n\r\n                that.interval = setInterval(function() {\r\n                    that.drawWave();\r\n                    that.detectSilence();\r\n                }, 100);\r\n\r\n            };\r\n\r\n\r\n\r\n            // Mic permission\r\n            var audioconstraints = true;\r\n            log.debug(\"Shadow is \" + shadow);\r\n            if(shadow===true){\r\n                audioconstraints =  {\r\n                    echoCancellation: false,\r\n                    noiseSuppression: false\r\n                }\r\n            }\r\n\r\n            //for ios we need to do this to keep playback volume high\r\n            if (\"audioSession\" in navigator) {\r\n                navigator.audioSession.type = 'play-and-record';\r\n                console.log(\"AudioSession API is supported\");\r\n            }\r\n\r\n            //get media stream\r\n            navigator.mediaDevices.getUserMedia({\r\n                audio:  audioconstraints,\r\n                video: false,\r\n\r\n            }).then(gotStreamMethod).catch(this.onError);\r\n        },\r\n\r\n        stop: function() {\r\n            clearInterval(this.interval);\r\n            this.canvasCtx.clearRect(0, 0, this.canvas.width()*2, this.waveHeight * 2);\r\n            this.isRecording = false;\r\n            this.silencecount=0;\r\n            this.alreadyhadsound=false;\r\n            this.therecorder.update_audio('isRecording',false);\r\n            //we check audiocontext is not in an odd state before closing\r\n            //superclickers can get it in an odd state\r\n            if (this.audioContext!==null && this.audioContext.state !== \"closed\") {\r\n                this.audioContext.close();\r\n            }\r\n            this.processor.disconnect();\r\n            this.tracks.forEach(function(track){track.stop();});\r\n            this.onStop(this.encoder.finish());\r\n        },\r\n\r\n        getBuffers: function(event) {\r\n            var buffers = [];\r\n            for (var ch = 0; ch < 2; ++ch) {\r\n                buffers[ch] = event.inputBuffer.getChannelData(ch);\r\n            }\r\n            return buffers;\r\n        },\r\n\r\n        detectSilence: function () {\r\n\r\n            this.listener.getByteFrequencyData(this.volumeData);\r\n\r\n            let sum = 0;\r\n            for (var vindex =0; vindex <this.volumeData.length;vindex++) {\r\n                sum += this.volumeData[vindex] * this.volumeData[vindex];\r\n            }\r\n\r\n            var volume = Math.sqrt(sum / this.volumeData.length);\r\n            // log.debug(\"volume: \" + volume + ', hadsound: ' + this.alreadyhadsound);\r\n            //if we already had a sound, we are looking for end of speech\r\n            if(volume < this.silencelevel && this.alreadyhadsound){\r\n                this.silencecount++;\r\n                if(this.silencecount>=this.silenceintervals){\r\n                    this.therecorder.silence_detected();\r\n                }\r\n                //if we have a sound, reset silence count to zero, and flag that we have started\r\n            }else if(volume > this.silencelevel){\r\n                this.alreadyhadsound = true;\r\n                this.silencecount=0;\r\n            }\r\n        },\r\n\r\n\r\n\r\n        drawWave: function() {\r\n\r\n            var width = this.canvas.width() * 2;\r\n            this.listener.getByteTimeDomainData(this.analyserData);\r\n\r\n            this.canvasCtx.fillStyle = 'white';\r\n            this.canvasCtx.fillRect(0, 0, width, this.waveHeight*2);\r\n\r\n            this.canvasCtx.lineWidth = 5;\r\n            this.canvasCtx.strokeStyle = 'gray';\r\n            this.canvasCtx.beginPath();\r\n\r\n            var slicewaveWidth = width / this.bufferLength;\r\n            var x = 0;\r\n\r\n            for (var i = 0; i < this.bufferLength; i++) {\r\n\r\n                var v = this.analyserData[i] / 128.0;\r\n                var y = v * this.waveHeight;\r\n\r\n                if (i === 0) {\r\n                    // this.canvasCtx.moveTo(x, y);\r\n                } else {\r\n                    this.canvasCtx.lineTo(x, y);\r\n                }\r\n\r\n                x += slicewaveWidth;\r\n            }\r\n\r\n            this.canvasCtx.lineTo(width, this.waveHeight);\r\n            this.canvasCtx.stroke();\r\n\r\n        }\r\n    }; //end of this declaration\r\n\r\n\r\n});"],"names":["define","$","log","wavencoder","debug","encoder","microphone","isRecording","audioContext","processor","uniqueid","alreadyhadsound","silencecount","silenceintervals","silencelevel","config","bufferLen","numChannels","mimeType","clone","extend","this","init","waveHeight","therecorder","prepare_html","window","AudioContext","webkitAudioContext","onStop","onStream","onError","canvas","canvasCtx","getContext","start","shadow","that","createJavaScriptNode","createScriptProcessor","connect","destination","audioconstraints","echoCancellation","noiseSuppression","navigator","audioSession","type","console","mediaDevices","getUserMedia","audio","video","then","stream","update_audio","tracks","getTracks","i","length","track","kind","settings","getSettings","createMediaStreamSource","sampleRate","onaudioprocess","event","encode","getBuffers","listener","createAnalyser","fftSize","bufferLength","frequencyBinCount","analyserData","Uint8Array","volumeData","clearRect","width","interval","setInterval","drawWave","detectSilence","catch","stop","clearInterval","state","close","disconnect","forEach","finish","buffers","ch","inputBuffer","getChannelData","getByteFrequencyData","sum","vindex","volume","Math","sqrt","silence_detected","getByteTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","slicewaveWidth","x","y","lineTo","stroke"],"mappings":"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"}