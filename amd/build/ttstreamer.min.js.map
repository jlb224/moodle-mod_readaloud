{"version":3,"file":"ttstreamer.min.js","sources":["../src/ttstreamer.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\r\n    \"use strict\"; // jshint ;_;\r\n    /*\r\n    This file is the streamer to assembly ai\r\n     */\r\n\r\n    log.debug('TT Streamer initialising');\r\n\r\n    return {\r\n\r\n        speechtoken: null,\r\n        socket: null,\r\n        audiohelper: null,\r\n        earlyaudio: [],\r\n        partials: [],\r\n        finals: [],\r\n        ready: false,\r\n        finaltext: '',\r\n\r\n        //for making multiple instances\r\n        clone: function () {\r\n            return $.extend(true, {}, this);\r\n        },\r\n\r\n        init: function(speechtoken, theaudiohelper) {\r\n            this.speechtoken = speechtoken;\r\n            this.audiohelper = theaudiohelper;\r\n            this.preparesocket();\r\n        },\r\n\r\n        preparesocket: async function(){\r\n            var that = this;\r\n\r\n            // establish wss with AssemblyAI (AAI) at 16000 sample rate\r\n            switch(this.audiohelper.region){\r\n                case 'frankfurt':\r\n                case 'london':\r\n                case 'dublin':\r\n                    //did not work\r\n               //     this.socket = await new WebSocket(\r\n               //         `wss://api.eu.assemblyai.com/v2/realtime/ws?sample_rate=16000&encoding=pcm_s16le&token=${this.speechtoken}`,\r\n                //    );\r\n                //    break;\r\n                default:\r\n                    this.socket = await new WebSocket(\r\n                        `wss://api.assemblyai.com/v2/realtime/ws?sample_rate=16000&encoding=pcm_s16le&token=${this.speechtoken}`,\r\n                    );\r\n            }\r\n            log.debug('TT Streamer socket prepared');\r\n            \r\n\r\n            // handle incoming messages which contain the transcription\r\n            this.socket.onmessage= function(message) {\r\n                let msg = \"\";\r\n                const res = JSON.parse(message.data);\r\n                switch(res.message_type){\r\n                    case 'PartialTranscript':\r\n                        that.partials[res.audio_start] = res.text;\r\n                        var keys = Object.keys(that.partials);\r\n                        keys.sort((a, b) => a - b);\r\n                        for (const key of keys) {\r\n                            if (that.partials[key]) {\r\n                                msg += ` ${that.partials[key]}`;\r\n                            }\r\n                        }\r\n                        that.audiohelper.oninterimspeechcapture(that.finaltext + ' ' + msg);\r\n                        break;\r\n\r\n                    case 'FinalTranscript':\r\n                        //clear partials if we have a final\r\n                        that.partials = [];\r\n                        //process finals\r\n                        that.finals[res.audio_start] = res.text;\r\n                        var keys = Object.keys(that.finals);\r\n                        keys.sort((a, b) => a - b);\r\n                        for (const key of keys) {\r\n                            if (that.finals[key]) {\r\n                                msg += ` ${that.finals[key]}`;\r\n                            }\r\n                        }\r\n                        that.finaltext = msg;\r\n                        //we do not send final speech capture event until the speaking session ends\r\n                        //that.audiohelper.onfinalspeechcapture(msg);\r\n                        that.audiohelper.oninterimspeechcapture(msg);\r\n                        log.debug('interim (final) transcript: ' + msg);\r\n                        break;\r\n                    case 'SessionBegins':\r\n                            log.debug('TT Streamer session begins');\r\n                            that.ready = true;\r\n                            break;      \r\n                    case 'SessionEnds':\r\n                            break;    \r\n                    case 'SessionInformation':\r\n                        break;\r\n                    case 'RealtimeError':\r\n                        log.debug(res.error);\r\n                        break;    \r\n                    default:\r\n                        break;\r\n                }\r\n                log.debug(msg);\r\n            };\r\n\r\n            this.socket.onopen = (event) => {\r\n                log.debug('TT Streamer socket opened');\r\n                that.partials = [];\r\n                that.finals = [];\r\n                that.audiohelper.onSocketReady('fromsocketopen');\r\n            };\r\n\r\n            this.socket.onerror = (event) => {\r\n                log.debug(event);\r\n                that.socket.close();\r\n            };\r\n\r\n            this.socket.onclose = (event) => {\r\n                log.debug(event);\r\n                that.socket = null;\r\n            };\r\n        },\r\n\r\n        audioprocess: function(stereodata) {\r\n            var that = this;\r\n            const base64data = this.binarytobase64(stereodata[0]);\r\n\r\n            //this would be an event that occurs after recorder has stopped or before we are ready\r\n            //session opening can be slower than socket opening, so store audio data until session is open\r\n            if(this.ready===undefined || !this.ready){\r\n                log.debug('TT Streamer storing base64 audio');\r\n                this.earlyaudio.push(base64data);\r\n\r\n            //session opened after we collected audio data, send earlyaudio first\r\n            }else if(this.earlyaudio.length > 0 ){\r\n                for (var i=0; i < this.earlyaudio.length; i++) {\r\n                    this.sendaudio(this.earlyaudio[i]);\r\n                }\r\n                //clear earlyaudio and send the audio we just got\r\n                this.earlyaudio = [];\r\n                this.sendaudio(base64data);\r\n\r\n            }else{\r\n                //just send the audio we got\r\n                log.debug('TT Streamer sending current audiodata');\r\n                this.sendaudio(base64data);\r\n            }\r\n        },\r\n\r\n        binarytobase64: function(monoaudiodata) {\r\n            var that = this;\r\n\r\n            //convert to 16 bit pcm\r\n            var tempbuffer = []\r\n            for (let i = 0; i < monoaudiodata.length; i++) {\r\n                const sample = Math.max(-1, Math.min(1, monoaudiodata[i]))\r\n                const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7fff\r\n                tempbuffer.push(intSample & 0xff)\r\n                tempbuffer.push((intSample >> 8) & 0xff)\r\n            }\r\n            var sendbuffer = new Uint8Array(tempbuffer)\r\n\r\n            // Encode binary string to base64\r\n            var binary = '';\r\n            for (var i = 0; i < sendbuffer.length; i++) {\r\n                binary += String.fromCharCode(sendbuffer[i]);\r\n            }\r\n            var base64 = btoa(binary);\r\n            return base64;\r\n        },\r\n\r\n        sendaudio: function(base64) {\r\n            var that = this;\r\n            //Send it off !!\r\n            if (that.socket) {\r\n                that.socket.send(\r\n                    JSON.stringify({\r\n                        audio_data: base64,\r\n                    }),\r\n                );\r\n            }\r\n        },\r\n\r\n        finish: function(mimeType) {\r\n            var that = this;\r\n\r\n            //this would be an event that occurs after recorder has stopped lets just ignore it\r\n            if(this.ready===undefined || !this.ready){\r\n                return;\r\n            }\r\n            log.debug('forcing end utterance');\r\n            //get any remanining transcription\r\n            if (that.socket) {\r\n                that.socket.send(\r\n                    JSON.stringify({\r\n                        force_end_utterance: true,\r\n                    }),\r\n                );\r\n            }\r\n            log.debug('timing out');\r\n            setTimeout(function() {\r\n                var msg = \"\";\r\n                var sets = [that.finals,that.partials];\r\n                for (const set of sets) {\r\n                    var keys = Object.keys(set);\r\n                    keys.sort((a, b) => a - b);\r\n                    for (const key of keys) {\r\n                        if (set[key]) {\r\n                            msg += ` ${set[key]}`;\r\n                        }\r\n                    }\r\n                }\r\n                log.debug('sending final speech capture event');\r\n                that.audiohelper.onfinalspeechcapture(msg);\r\n                that.cleanup();\r\n            }, 1000);\r\n        },\r\n\r\n        cancel: function() {\r\n           this.ready = false;\r\n           this.earlyaudio = [];\r\n           this.partials = [];\r\n           this.finals = [];\r\n           this.finaltext = '';\r\n           if(this.socket){\r\n               this.socket.close();\r\n           }\r\n        },\r\n\r\n        cleanup: function() {\r\n            this.cancel();\r\n        }\r\n\r\n     };//end of return value\r\n\r\n});"],"names":["define","$","log","debug","speechtoken","socket","audiohelper","earlyaudio","partials","finals","ready","finaltext","clone","extend","this","init","theaudiohelper","preparesocket","async","that","region","WebSocket","onmessage","message","msg","res","JSON","parse","data","message_type","audio_start","text","keys","Object","sort","a","b","key","oninterimspeechcapture","error","onopen","event","onSocketReady","onerror","close","onclose","audioprocess","stereodata","base64data","binarytobase64","undefined","length","i","sendaudio","push","monoaudiodata","tempbuffer","sample","Math","max","min","intSample","sendbuffer","Uint8Array","binary","String","fromCharCode","btoa","base64","send","stringify","audio_data","finish","mimeType","force_end_utterance","setTimeout","sets","set","onfinalspeechcapture","cleanup","cancel"],"mappings":"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"}